<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self'; 
        script-src 'self' https://cdnjs.cloudflare.com 'unsafe-inline'; 
        style-src 'self' https://cdnjs.cloudflare.com 'unsafe-inline'; 
        img-src 'self' data: https:;
        font-src 'self' https://cdnjs.cloudflare.com;
        connect-src 'none';
        frame-src 'none';
        object-src 'none';
        base-uri 'self';
        form-action 'none';
    ">
    <title>Universal AI Chat Exporter</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown-light.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/11.1.1/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>

    <style>
        :root {
            --primary-color: #2563eb;
            --primary-hover: #1d4ed8;
            --bg-color: #e5e7eb;
            --header-bg: #111827;
            --paper-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --border-color: #e5e7eb;
            --text-muted: #6b7280;
            --success-color: #10b981;

            /* Chat Bubble Colors */
            --bubble-user-bg: #2563eb; /* Royal Blue */
            --bubble-user-text: #ffffff;
            --bubble-ai-bg: #f3f4f6;   /* Soft Gray */
            --bubble-ai-text: #1f2937;
        }

        /* --- Dark Mode Palette --- */
        body.dark-mode {
            --bg-color: #1f2937;
            --header-bg: #111827;
            --border-color: #374151;
            --text-color: #f9fafb;
            --text-muted: #9ca3af;

            /* Invert bubble colors */
            --bubble-user-bg: #374151;
            --bubble-user-text: #f9fafb;
            --bubble-ai-bg: #4b5563;
            --bubble-ai-text: #f9fafb;
        }

        body.dark-mode .preview-pane { background-color: var(--bg-color); }
        body.dark-mode #document-sheet { background-color: #1f2937; box-shadow: none; }
        body.dark-mode .doc-header { border-bottom-color: var(--border-color); }
        body.dark-mode .pane-header { background: #111827; border-bottom-color: var(--border-color); color: var(--text-muted); }
        body.dark-mode .editor-pane { background: #1f2937; }
        body.dark-mode textarea { background: #1f2937; color: var(--text-color); }
        body.dark-mode textarea:focus { background: #111827; }
        body.dark-mode .editable:hover { background: #374151; }
        body.dark-mode .editable:focus { background: #4b5563; }
        body.dark-mode .editable { color: var(--text-color); }
        body.dark-mode .chat-row.ai .chat-bubble { border-color: var(--border-color); }
        body.dark-mode .chat-row.user .chat-bubble .markdown-body,
        body.dark-mode .chat-row.ai .chat-bubble .markdown-body {
            color: var(--bubble-ai-text); /* Use the same white for both */
        }
        
        /* --- Ocean Breeze Theme --- */
        body.theme-ocean-breeze {
            --bg-color: #E0F7FA;
            --header-bg: #004D40;
            --border-color: #B2EBF2;
            --primary-color: #00796B;
            --primary-hover: #004D40;
            --text-muted: #263238;
            --bubble-user-bg: #00796B;
            --bubble-user-text: #ffffff;
            --bubble-ai-bg: #E0F7FA;
            --bubble-ai-text: #263238;
        }
        body.theme-ocean-breeze .preview-pane, body.theme-ocean-breeze #document-sheet { background-color: #F0FEFF; }

        /* --- Sunset Glow Theme --- */
        body.theme-sunset-glow {
            --bg-color: #FFF3E0;
            --header-bg: #D84315;
            --border-color: #FFCC80;
            --primary-color: #FB8C00;
            --primary-hover: #D84315;
            --text-muted: #4E342E;
            --bubble-user-bg: #FB8C00;
            --bubble-user-text: #ffffff;
            --bubble-ai-bg: #FFF3E0;
            --bubble-ai-text: #4E342E;
        }
        body.theme-sunset-glow .preview-pane, body.theme-sunset-glow #document-sheet { background-color: #FFF9F2; }

        /* --- Tropical Vibes Theme --- */
        body.theme-tropical-vibes {
            --bg-color: #F1F8E9;
            --header-bg: #FFEB3B;
            --border-color: #C5E1A5;
            --primary-color: #43A047;
            --primary-hover: #1B5E20;
            --text-muted: #1B5E20;
            --bubble-user-bg: #43A047;
            --bubble-user-text: #ffffff;
            --bubble-ai-bg: #F1F8E9;
            --bubble-ai-text: #1B5E20;
        }
        body.theme-tropical-vibes .preview-pane, body.theme-tropical-vibes #document-sheet { background-color: #F8FCF4; }

        /* --- Coral Reef Theme --- */
        body.theme-coral-reef {
            --bg-color: #FCE4EC;
            --header-bg: #F06292;
            --border-color: #F8BBD0;
            --primary-color: #E91E63;
            --primary-hover: #880E4F;
            --text-muted: #880E4F;
            --bubble-user-bg: #E91E63;
            --bubble-user-text: #ffffff;
            --bubble-ai-bg: #FCE4EC;
            --bubble-ai-text: #880E4F;
        }
        body.theme-coral-reef .preview-pane, body.theme-coral-reef #document-sheet { background-color: #FDF6F8; }

        /* --- Sky & Sand Theme --- */
        body.theme-sky-sand {
            --bg-color: #FFF8E1;
            --header-bg: #03A9F4;
            --border-color: #81D4FA;
            --primary-color: #0288D1;
            --primary-hover: #01579B;
            --text-muted: #37474F;
            --bubble-user-bg: #0288D1;
            --bubble-user-text: #ffffff;
            --bubble-ai-bg: #FFF8E1;
            --bubble-ai-text: #37474F;
        }
        body.theme-sky-sand .preview-pane, body.theme-sky-sand #document-sheet { background-color: #FFFBF2; }

        /* --- Citrus Pop Theme --- */
        body.theme-citrus-pop {
            --bg-color: #FFFDE7;
            --header-bg: #FF5722;
            --border-color: #FFD54F;
            --primary-color: #FBC02D;
            --primary-hover: #FFA000;
            --text-muted: #3E2723;
            --bubble-user-bg: #FBC02D;
            --bubble-user-text: #3E2723;
            --bubble-ai-bg: #FFFDE7;
            --bubble-ai-text: #3E2723;
        }
        body.theme-citrus-pop .preview-pane, body.theme-citrus-pop #document-sheet { background-color: #FFFEEF; }

        /* --- Lavender Fields Theme --- */
        body.theme-lavender-fields {
            --bg-color: #F3E5F5;
            --header-bg: #CE93D8;
            --border-color: #E1BEE7;
            --primary-color: #9C27B0;
            --primary-hover: #4A148C;
            --text-muted: #4A148C;
            --bubble-user-bg: #9C27B0;
            --bubble-user-text: #ffffff;
            --bubble-ai-bg: #F3E5F5;
            --bubble-ai-text: #4A148C;
        }
        body.theme-lavender-fields .preview-pane, body.theme-lavender-fields #document-sheet { background-color: #F9F4FA; }

        /* --- Aqua Coral Theme --- */
        body.theme-aqua-coral {
            --bg-color: #E0F2F1;
            --header-bg: #FF7043;
            --border-color: #A7FFEB;
            --primary-color: #009688;
            --primary-hover: #004D40;
            --text-muted: #004D40;
            --bubble-user-bg: #009688;
            --bubble-user-text: #ffffff;
            --bubble-ai-bg: #E0F2F1;
            --bubble-ai-text: #004D40;
        }
        body.theme-aqua-coral .preview-pane, body.theme-aqua-coral #document-sheet { background-color: #F0FAF9; }

        /* --- Berry Burst Theme --- */
        body.theme-berry-burst {
            --bg-color: #F8BBD0;
            --header-bg: #F06292;
            --border-color: #F48FB1;
            --primary-color: #AD1457;
            --primary-hover: #880E4F;
            --text-muted: #4A148C;
            --bubble-user-bg: #AD1457;
            --bubble-user-text: #ffffff;
            --bubble-ai-bg: #F8BBD0;
            --bubble-ai-text: #4A148C;
        }
        body.theme-berry-burst .preview-pane, body.theme-berry-burst #document-sheet { background-color: #FCE4EC; }

        /* --- Fresh Lime Theme --- */
        body.theme-fresh-lime {
            --bg-color: #F1F8E9;
            --header-bg: #CDDC39;
            --border-color: #DCE775;
            --primary-color: #8BC34A;
            --primary-hover: #558B2F;
            --text-muted: #33691E;
            --bubble-user-bg: #8BC34A;
            --bubble-user-text: #33691E;
            --bubble-ai-bg: #F1F8E9;
            --bubble-ai-text: #33691E;
        }
        body.theme-fresh-lime .preview-pane, body.theme-fresh-lime #document-sheet { background-color: #F8FCF4; }

        * { box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            min-height: 100vh;
            height: 100vh;
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s;
        }

        /* --- App Header --- */
        header {
            background-color: var(--header-bg);
            color: white;
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #374151;
            z-index: 10;
            flex-wrap: wrap;
            gap: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            background-color: #4b5563;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .btn:hover { background-color: #6b7280; }
        .btn-print { background-color: var(--primary-color); }
        .btn-print:hover { background-color: var(--primary-hover); }
        .btn-success { background-color: var(--success-color); }
        .btn-success:hover { background-color: #059669; }

        .status {
            font-size: 0.85rem;
            color: #9ca3af;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .status.saved { color: var(--success-color); }

        /* --- Main Layout --- */
        .workspace {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* --- Input Side --- */
        .editor-pane {
            width: 35%;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            background: white;
            z-index: 5;
        }

        .pane-header {
            padding: 10px 20px;
            background: #f9fafb;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-muted);
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        textarea {
            flex: 1;
            width: 100%;
            border: none;
            padding: 20px;
            resize: none;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            outline: none;
            color: #374151;
            background: #fff;
        }
        textarea:focus { background: #fafafa; }

        /* --- Preview Side --- */
        .preview-pane {
            width: 65%;
            background-color: white;
            background-color: var(--bg-color);
            overflow-y: auto;
            padding: 40px;
            display: flex;
            justify-content: center;
        }

        #document-sheet {
            background-color: white;
            width: 100%; 
            max-width: 210mm; /* A4 Width */
            padding: 20mm;
            box-shadow: none;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        /* --- Document Header --- */
        .doc-header {
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 20px;
            margin-bottom: 30px;
        }

        .editable {
            border: none;
            outline: none;
            width: 100%;
            background: transparent;
            transition: background 0.2s;
            border-radius: 4px;
            padding: 4px 6px;
        }
        .editable:hover { background: #f3f4f6; }
        .editable:focus { background: #eff6ff; }

        .doc-title {
            font-size: 24px;
            font-weight: 800;
            color: #111827;
            margin-bottom: 10px;
            line-height: 1.3;
            max-height: 105px; /* Approx 3 lines */
            overflow-y: auto;
        }

        body.dark-mode .doc-title,
        body.dark-mode .meta-row {
            color: #d1d5db;
            color: var(--text-color);
        }

        .meta-row {
            display: flex;
            gap: 20px;
            color: var(--text-muted);
            font-size: 14px;
            font-weight: 500;
        }

        /* --- Chat Bubble Styling --- */
        .chat-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
            width: 100%;
        }

        .chat-row {
            display: flex;
            width: 100%;
            margin-bottom: 8px;
        }

        .chat-row.user {
            justify-content: flex-end;
        }

        .chat-row.ai {
            justify-content: flex-start;
        }

        .chat-bubble {
            max-width: 85%;
            padding: 12px 18px;
            border-radius: 18px;
            position: relative;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            font-size: 15px;
            line-height: 1.5;
        }

        /* User Bubble Style */
        .chat-row.user .chat-bubble {
            background-color: var(--bubble-user-bg);
            color: var(--bubble-user-text);
            border-bottom-right-radius: 4px; /* Subtle tail effect */
        }
        
        /* Fix link colors in user bubbles (blue bg needs white text) */
        .chat-row.user .chat-bubble a { color: #bfdbfe; }
        .chat-row.user .chat-bubble code { background: rgba(255,255,255,0.2); color: white; }
        .chat-row.user .chat-bubble pre { background: rgba(0,0,0,0.2); }

        /* AI Bubble Style */
        .chat-row.ai .chat-bubble {
            background-color: var(--bubble-ai-bg);
            color: var(--bubble-ai-text);
            border-bottom-left-radius: 4px; /* Subtle tail effect */
            border: 1px solid #e5e7eb;
        }

        .speaker-label {
            font-size: 0.7rem;
            margin-bottom: 4px;
            opacity: 0.7;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Standard Markdown Override for Bubbles */
        .markdown-body {
            background: transparent !important;
            font-family: inherit !important;
            font-size: inherit !important;
        }
        .chat-bubble .markdown-body p { margin-bottom: 0.5em; }
        .chat-bubble .markdown-body p:last-child { margin-bottom: 0; }
        
        /* Style for editable bubbles */
        .markdown-body[contenteditable="true"]:hover {
            outline: 1px dashed var(--primary-color);
            cursor: text;
        }

        /* Fallback for non-chat text */
        .standard-doc {
            font-size: 11pt;
            line-height: 1.6;
        }

        /* --- Toast & Utils --- */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #111827;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }
        .toast.show { display: flex; }
        @keyframes slideIn { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        /* --- Responsive --- */
        @media (max-width: 1024px) {
            .workspace { flex-direction: column; height: auto; }
            .editor-pane { width: 100%; height: 40vh; border-right: none; border-bottom: 1px solid var(--border-color); }
            .preview-pane { width: 100%; height: auto; }
            .editor-pane { width: 100%; height: 50vh; min-height: 300px; border-right: none; border-bottom: 1px solid var(--border-color); }
            .preview-pane { width: 100%; height: auto; flex-grow: 1; }
            .editor-pane { width: 100%; height: 50vh; border-right: none; border-bottom: 1px solid var(--border-color); }
            .preview-pane { width: 100%; height: 50vh; }
            body { overflow-y: auto; }
        }

        /* --- Print Mode --- */
        @media print {
            @page { margin: 10mm; size: A4; }
            body { background: white; display: block; height: auto; }
            header, .editor-pane, .toast { display: none !important; }
            .preview-pane { width: 100%; padding: 0; background: white; display: block; overflow: visible; }
            #document-sheet { width: 100%; max-width: none; box-shadow: none; padding: 0; margin: 0; min-height: auto; }
            
            /* Print tweaks for bubbles */
            .chat-bubble { 
                border: 1px solid #ddd; 
                page-break-inside: avoid;
                box-shadow: none;
            }
            .chat-row.user .chat-bubble {
                background-color: #f0f7ff; /* Lighter blue for print ink saving */
                border-color: #2563eb;
            }
            /* Ensure all text inside user bubbles is black for print, avoiding !important */
            .chat-row.user .chat-bubble,
            .chat-row.user .chat-bubble .markdown-body,
            .chat-row.user .chat-bubble a {
                color: black;
            }
            .chat-row.user .chat-bubble code,
            .chat-row.ai .chat-bubble code { 
                border: 1px solid #ddd;
            }
            /* Prevent bubbles from splitting across pages */
            .chat-row, .chat-bubble {
                page-break-inside: avoid;
                break-inside: avoid;
            }
        }
        @media print {
            .chat-row, .chat-bubble {
                page-break-inside: avoid;
                break-inside: avoid;
            }
        }
    </style>
</head>
<body>

<header role="banner">
    <div class="brand">
        <svg fill="none" stroke="currentColor" stroke-width="2" width="24" height="24" viewBox="0 0 24 24" aria-hidden="true">
            <path stroke-linecap="round" stroke-linejoin="round" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"></path>
        </svg>
        <span>AI Chat Exporter</span>
    </div>
    <div class="status" id="saveStatus"></div>
    <div class="controls" role="navigation" aria-label="Main controls">
        <button type="button" class="btn" onclick="Storage.load()" aria-label="Load saved draft">Load</button>
        <button type="button" class="btn" onclick="setTheme('light')" aria-label="Switch to light theme">Light</button>
        <button type="button" class="btn" onclick="setTheme('dark')" aria-label="Switch to dark theme">Dark Mode</button>
        <button type="button" class="btn" onclick="cycleTheme()" aria-label="Cycle to next theme">Cycle Theme</button>
        <button type="button" class="btn btn-success" onclick="Storage.save()" aria-label="Save current draft">Save</button>
        <button type="button" class="btn" onclick="clearText()" aria-label="Clear all content">Clear</button>
        <button type="button" class="btn btn-print" onclick="window.print()" aria-label="Print or export to PDF">Export PDF</button>
    </div>
</header>

<main role="main">
<div class="workspace">
    <div class="editor-pane">
        <div class="pane-header">
            <span>Input (Markdown/Text)</span>
            <span class="char-count" id="charCount">0 chars</span>
        </div>
        <div style="padding: 10px 20px; border-bottom: 1px solid var(--border-color); background: #f9fafb;">
            <button type="button" class="btn" onclick="pasteFromClipboard()">Paste Copied Text</button>
            <div style="font-size: 0.85rem; color: var(--text-muted); margin-top: 10px;">
                <strong>Instructions:</strong>
                <ol>
                    <li>Paste your chat conversation into the text area below.</li>
                    <li>The app will automatically format it into chat bubbles.</li>
                    <li>Edit the Title, Date, and Source fields in the preview.</li>
                    <li>Use the "Export PDF" button to save your chat.</li>
                </ol>
                <div style="font-size: 0.8rem; color: #777; margin-top: 10px; border-top: 1px solid var(--border-color); padding-top: 8px;">
                    <strong style="color: var(--primary-color);">Privacy Note:</strong> All data is stored locally in your browser.
                    It is never sent to a server. Use the "Clear" button to erase all data.
                </div>
            </div>
        </div>
        <textarea 
            id="inputBox" 
            placeholder="Paste your conversation here.&#10;&#10;The tool will auto-detect speakers if lines start with:&#10;'User:', 'You', 'AI:', 'ChatGPT', 'Claude', etc."
            spellcheck="false"
            autocomplete="off"
        ></textarea>
    </div>

    <div class="preview-pane">
        <div id="document-sheet">
            <div class="doc-header">
                <div contenteditable="true" class="editable doc-title" id="docTitle" aria-label="Document Title" role="textbox">Enter Title Here</div>
                <div class="meta-row">
                    <span>Date: <input type="text" class="editable" id="dateField" style="width:150px" value="Enter Date Here" autocomplete="off" aria-label="Document Date"></span>
                    <span>Source: <input type="text" class="editable" id="sourceField" value="Enter Source Here" style="width:150px" autocomplete="off" aria-label="Conversation Source"></span>
                </div>
            </div>

            <div id="outputContent">
                <p style="color:#9ca3af; font-style:italic; text-align:center;">Preview will appear here...</p>
            </div>
        </div>
    </div>
</div>
</main>

<div class="toast" id="toast"></div>

<script>
    // === GLOBAL ERROR HANDLING ===
    window.addEventListener('error', (e) => {
        console.error('Global error:', e.error);
        showToast('An error occurred. Check console for details.');
    });

    window.addEventListener('unhandledrejection', (e) => {
        console.error('Unhandled promise rejection:', e.reason);
        showToast('An async error occurred. Check console for details.');
    });

    // === CONFIGURATION ===
    const CONFIG = {
        MAX_INPUT_SIZE: 5 * 1024 * 1024, // 5MB
        AUTO_SAVE_DELAY: 2000,
        RENDER_DEBOUNCE: 250,
        USER_KEYWORDS: ['user', 'you', 'me', 'human', 'prompter'],
        AI_KEYWORDS: ['ai', 'chatgpt', 'claude', 'gemini', 'grok', 'llama', 'copilot', 'assistant', 'model', 'bot']
    };

    marked.setOptions({ breaks: true, gfm: true, strikethrough: false });

    // === STATE MANAGEMENT ===
    const State = {
        renderTimeout: null,
        autoSaveTimeout: null,
        isUpdatingFromPreview: false,
        speakerColorCache: {},
        currentThemeIndex: 0
    };

    // === DOM ELEMENTS ===
    const elements = {
        input: document.getElementById('inputBox'),
        output: document.getElementById('outputContent'),
        title: document.getElementById('docTitle'),
        date: document.getElementById('dateField'),
        source: document.getElementById('sourceField'),
        count: document.getElementById('charCount'),
        status: document.getElementById('saveStatus')
    };

    // --- Theme Management ---
    const themes = [
        'light', 
        'dark', 
        'ocean-breeze', 
        'sunset-glow', 
        'tropical-vibes', 
        'coral-reef', 
        'sky-sand', 
        'citrus-pop', 
        'lavender-fields', 
        'aqua-coral', 
        'berry-burst', 
        'fresh-lime'
    ];

    // SECURE: Whitelist of valid themes
    const VALID_THEMES = [
        'light', 
        'dark', 
        'ocean-breeze', 
        'sunset-glow', 
        'tropical-vibes', 
        'coral-reef', 
        'sky-sand', 
        'citrus-pop', 
        'lavender-fields', 
        'aqua-coral', 
        'berry-burst', 
        'fresh-lime'
    ];

    function getColorForSpeaker(speaker) {
        if (State.speakerColorCache[speaker]) {
            return State.speakerColorCache[speaker];
        }
        // Deterministic hash function to get a consistent hue from the speaker's name.
        let hash = 0;
        for (let i = 0; i < speaker.length; i++) {
            hash = speaker.charCodeAt(i) + ((hash << 5) - hash);
        }
        const hue = Math.abs(hash) % 360;
        // Use a fixed saturation and lightness suitable for dark backgrounds.
        const color = `hsl(${hue}, 90%, 75%)`;
        State.speakerColorCache[speaker] = color;
        return color;
    }

    function escapeRegex(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    // Pre-compile keyword regexes for performance.
    const userKeywordRegex = new RegExp(`\\b(${CONFIG.USER_KEYWORDS.map(escapeRegex).join('|')})\\b`, 'i');
    const aiKeywordRegex = new RegExp(`\\b(${CONFIG.AI_KEYWORDS.map(escapeRegex).join('|')})\\b`, 'i');

    function init() {
        const savedTheme = localStorage.getItem('chatTheme');
        // SECURE: Validate saved theme
        setTheme(VALID_THEMES.includes(savedTheme) ? savedTheme : 'light');
        resetMetaOnReload();
        
        // Set date if still empty after potential reload reset
        if (!elements.date.value || elements.date.value === "Enter Date Here") {
            const today = new Date();
            elements.date.value = today.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
        }
        
        elements.input.addEventListener('input', () => {
            if (elements.input.value.length > CONFIG.MAX_INPUT_SIZE) {
                elements.input.value = elements.input.value.substring(0, CONFIG.MAX_INPUT_SIZE);
                showToast(`Input truncated to ${(CONFIG.MAX_INPUT_SIZE / 1024 / 1024).toFixed(1)}MB limit`);
            }
            handleInput(true); // Debounce rendering
        });
        // Handle rich text pasting by converting it to clean plain text
        elements.input.addEventListener('paste', handlePaste);
        
        // --- CRITICAL SECURITY FIX: Sanitize contenteditable inputs ---
        // 1. Force all pastes into contenteditable bubbles to be plain text.
        elements.output.addEventListener('paste', (e) => {
            if (e.target && e.target.matches('.markdown-body[contenteditable="true"]')) {
                e.preventDefault();
                const text = (e.clipboardData || window.clipboardData).getData('text/plain');
                document.execCommand('insertText', false, text);
            }
        }, true); // Use capture phase

        // 2. Sanitize any input (typing, drag-drop, etc.) in real-time.
        elements.output.addEventListener('input', (e) => {
            if (e.target && e.target.matches('.markdown-body[contenteditable="true"]')) {
                // Immediately sanitize any pasted/edited content
                const clean = DOMPurify.sanitize(e.target.innerHTML, {
                    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'code', 'pre', 'ul', 'ol', 'li', 'blockquote'],
                    ALLOWED_ATTR: ['class'],
                    ALLOW_DATA_ATTR: false
                });
                if (clean !== e.target.innerHTML) {
                    e.target.innerHTML = clean;
                    // Reposition cursor at the end after sanitization
                    const range = document.createRange();
                    const sel = window.getSelection();
                    range.selectNodeContents(e.target);
                    range.collapse(false);
                    sel.removeAllRanges();
                    sel.addRange(range);
                    showToast("Potentially dangerous content was removed");
                }
            }
        }, true); // Use capture phase

        // Tab support in textarea
        elements.input.addEventListener('keydown', function(e) {
            if (e.key === 'Tab') {
                e.preventDefault();
                document.execCommand('insertText', false, "    ");
            }
        });

        // Use event delegation to handle edits within the preview pane
        elements.output.addEventListener('blur', (e) => {
            // When a user clicks away from an edited bubble, update the source text
            if (e.target && e.target.matches('.markdown-body[contenteditable="true"]')) {
                updateSourceFromPreview();
            }
        }, true); // Use capture phase to ensure the event is caught reliably.

        // Accessibility: Keyboard navigation for bubbles
        elements.output.addEventListener('keydown', (e) => {
            if (e.key === 'Tab' && e.target.matches('.markdown-body[contenteditable="true"]')) {
                const bubbles = Array.from(elements.output.querySelectorAll('.markdown-body[contenteditable="true"]'));
                const currentIndex = bubbles.indexOf(e.target);
                
                if (e.shiftKey && currentIndex > 0) {
                    e.preventDefault();
                    bubbles[currentIndex - 1].focus();
                } else if (!e.shiftKey && currentIndex < bubbles.length - 1) {
                    e.preventDefault();
                    bubbles[currentIndex + 1].focus();
                }
            }
        });

        // Add confirmation before leaving the page if there's unsaved text
        window.addEventListener('beforeunload', (e) => {
            // Clear all pending timers to prevent memory leaks on unload
            if (State.renderTimeout) clearTimeout(State.renderTimeout);
            if (State.autoSaveTimeout) clearTimeout(State.autoSaveTimeout);

            if (elements.input.value.trim().length > 0) {
                // Standard way to trigger the browser's confirmation dialog
                e.preventDefault();
                e.returnValue = '';
            }
        });

        // loadAutoSave(); // Disabled for privacy on shared computers. User must explicitly click "Load".
    }

    function setTheme(theme) {
        // SECURE: Validate theme against whitelist
        if (!VALID_THEMES.includes(theme)) {
            console.warn(`Invalid theme: ${theme}. Defaulting to light.`);
            theme = 'light';
        }

        // Remove all possible theme classes
        document.body.className = document.body.className.replace(/theme-\S+|dark-mode/g, '').trim();

        if (theme !== 'light') {
            const className = theme === 'dark' ? 'dark-mode' : `theme-${theme}`;
            document.body.classList.add(className);
        }
        
        localStorage.setItem('chatTheme', theme);
        const themeIndex = VALID_THEMES.indexOf(theme);
        State.currentThemeIndex = themeIndex !== -1 ? themeIndex : 0;
    }

    function cycleTheme() {
        State.currentThemeIndex = (State.currentThemeIndex + 1) % themes.length;
        const nextTheme = themes[State.currentThemeIndex];
        setTheme(nextTheme);
    }

    function resetMetaOnReload() {
      const wasReload = performance.getEntriesByType('navigation')[0]?.type === 'reload';
      if (wasReload) {
        resetFields();
      }
    }

    function resetFields() {
      elements.title.textContent = 'Enter Title Here';
      elements.source.value = 'Enter Source Here';
      const today = new Date();
      elements.date.value = today.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
    }

    async function pasteFromClipboard() {
        try {
            if (!navigator.clipboard || !navigator.clipboard.read) {
                showToast('Clipboard API not supported. Please use Ctrl+V / Cmd+V to paste.');
                return;
            }

            const permission = await navigator.permissions.query({ name: 'clipboard-read' });
            if (permission.state === 'denied') {
                showToast('Clipboard access denied. Please use Ctrl+V to paste.');
                return;
            }

            try { // Nested try for the actual read operation
                const clipboardItems = await navigator.clipboard.read();
                let pastedText = '';

                for (const item of clipboardItems) {
                    if (item.types.includes('text/html')) {
                        const blob = await item.getType('text/html');
                        const htmlText = await blob.text();
                        pastedText = convertHtmlToPreserveBreaks(htmlText);
                        break; 
                    } else if (item.types.includes('text/plain') && !pastedText) {
                        const blob = await item.getType('text/plain');
                        pastedText = await blob.text();
                    }
                }
                
                if (pastedText) {
                    const input = elements.input;
                    const selStart = input.selectionStart;
                    const selEnd = input.selectionEnd;
                    const currentText = input.value;
                    input.value = currentText.substring(0, selStart) + pastedText + currentText.substring(selEnd);
                    input.selectionStart = input.selectionEnd = selStart + pastedText.length;
                    handleInput();
                } else {
                    showToast('No text found on clipboard.');
                }

            } catch (readErr) {
                console.error('Failed to read clipboard: ', readErr);
                showToast('Could not read clipboard. Please use Ctrl+V / Cmd+V to paste.');
            }
        } catch (permErr) {
            console.error('Clipboard permission error: ', permErr);
            showToast('Could not access clipboard. Please use Ctrl+V / Cmd+V.');
        }

    }

    function handlePaste(e) {
        e.preventDefault();
        const cd = e.clipboardData || window.clipboardData;
        let pastedText = '';

        const html = cd.getData('text/html');
        const plain = cd.getData('text/plain');

        if (html) {
            pastedText = convertHtmlToPreserveBreaks(html);
        } else if (plain) {
            pastedText = plain;
        }

        // Aggressively clean invisible characters and normalize whitespace
        pastedText = pastedText
            .replace(/[\u200B-\u200D\uFEFF]/g, '') // Remove zero-width spaces
            .replace(/\r\n/g, '\n') // Normalize line endings
            .replace(/\n{3,}/g, '\n\n'); // Collapse excessive blank lines

        document.execCommand('insertText', false, pastedText.trim());
    }

    function convertHtmlToPreserveBreaks(htmlString) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = htmlString;

        // Add newlines before block elements to ensure they are on a new line
        tempDiv.querySelectorAll('p, div, li, h1, h2, h3, blockquote').forEach(el => {
            el.insertAdjacentText('beforebegin', '\n'); 
        });
        
        // Replace <br> tags with newlines
        tempDiv.querySelectorAll('br').forEach(br => br.replaceWith('\n'));

        // Use textContent which is more literal than innerText
        let text = tempDiv.textContent || '';
        
        // Clean up excessive newlines, preserving up to two for paragraph breaks
        text = text.replace(/(\n\s*){3,}/g, '\n\n');

        return text.trim();
    }

    function handleInput(debounce = false) {
        if (State.renderTimeout) {
            clearTimeout(State.renderTimeout);
            State.renderTimeout = null;
        }

        const process = () => {
            const text = elements.input.value;
            elements.count.textContent = `${text.length.toLocaleString()} chars`;
            
            // Parse once, use twice for performance.
            const segments = Parser.parseSegments(text);
            Renderer.renderChat(text, segments);
            updateMetadata(text, segments);
            Storage.scheduleAutoSave();
            State.renderTimeout = null;
        };

        if (debounce) {
            State.renderTimeout = setTimeout(process, CONFIG.RENDER_DEBOUNCE);
        } else {
            process();
        }
    }

    function updateMetadata(text, segments = null) {
        if (!segments) segments = Parser.parseSegments(text);

        // 1. Detect LLM source only if it's the default or empty
        if (elements.source.value === 'Enter Source Here' || elements.source.value === 'AI Assistant' || !elements.source.value) {
            const aiSegments = segments.filter(s => s.type === 'ai');
            let detectedSource = null;
            if (aiSegments.length > 0) {
                // Find the first AI speaker that isn't just "AI"
                const specificAi = aiSegments.find(s => s.speaker.toLowerCase() !== 'ai' && s.speaker.toLowerCase() !== 'assistant');
                if (specificAi) {
                    detectedSource = specificAi.speaker;
                } else if (aiSegments.length > 0) {
                    detectedSource = aiSegments[0].speaker; // Fallback to the first one, e.g., "AI"
                }
            }

            if (detectedSource) {
                elements.source.value = detectedSource;
            } else {
                elements.source.value = 'AI Assistant';
            }
        }

        // 2. Detect Topic only if it's the default or empty
        if (elements.title.textContent === 'Enter Title Here' || elements.title.textContent === 'Conversation Log' || !elements.title.textContent) {
            let potentialTitle = "Conversation Log";
            const lines = text.trim().split('\n');

            if (lines.length > 0) {
                const firstSignificantLine = lines.find(l => l.trim().length > 0) || '';
                // A "heading" is a good title candidate.
                if (firstSignificantLine.trim().startsWith('#')) {
                    potentialTitle = firstSignificantLine.trim().replace(/^#+\s*/, '').trim();
                } else {
                    // Otherwise, find the first bit of user content.
                    const userSegments = segments.filter(s => s.type === 'user' && s.content.trim().length > 0);
                    if (userSegments.length > 0) {
                        const firstUserContent = userSegments[0].content.trim();
                        // Take the first line of the user's message
                        potentialTitle = firstUserContent.split('\n')[0].trim();
                        // Truncate if it's too long
                        if (potentialTitle.length > 60) {
                            potentialTitle = potentialTitle.substring(0, 57) + "...";
                        }
                    }
                    // If we still have nothing, don't change from default
                    if (potentialTitle.trim() === '...' || potentialTitle.trim() === '') potentialTitle = "Conversation Log";
                }
            }
            elements.title.textContent = potentialTitle;
        }
    }

    // === PARSER MODULE ===
    const Parser = {
    /**
     * Parses conversation text into structured segments using multiple strategies.
     * @param {string} text - Raw conversation text.
     * @returns {Array<{type: string, speaker: string, content: string}>} Parsed segments.
     * @throws {Error} If text is not a string.
     */
    parseSegments(text) {
        // This function combines multiple parsing strategies to create a list of chat segments.
        let segments = this.parseByLabels(text);

        const hasKnownLabels = segments.some(s => s.type === 'user' || s.type === 'ai');
        if (segments.length < 2 || !hasKnownLabels) {
            const alternateSegments = this.parseByAlternatingTurns(text);
            if (alternateSegments.length > 1) {
                segments = alternateSegments;
            }
        }
        
        if (segments.length < 2) {
             const heuristicSegments = this.parseByHeuristicSplit(text);
             if (heuristicSegments.length > 1) {
                 segments = heuristicSegments;
             }
        }
        
        return segments.filter(seg => seg.content.trim());
    },

    parseByLabels(text) {
        const lines = text.split('\n');
        const segments = [];
        let currentSegment = { type: 'unknown', speaker: 'Unknown', content: '' };

        // --- Hardened Speaker Detection ---
        // 1. Permissive Regex: Catches any name followed by a colon, e.g., "Shawn:", "Patrick (User):"
        const permissiveSpeakerRegex = /^(.+?):\s+/;
        // 2. Keyword Regex (Fallback): Catches keywords like "User", "AI", "ChatGPT" even without a colon.
        const keywordSpeakerRegex = new RegExp(`^(\\*\\*|##\\s|)?(\\s*)(${[...CONFIG.USER_KEYWORDS, ...CONFIG.AI_KEYWORDS].join('|')})(\\*\\*|:|\\s+said)?`, 'i');

        lines.forEach(line => {
            let match = line.match(permissiveSpeakerRegex);
            let speakerName, isUser, isAi;

            let originalPrefix = '';
            if (match && match[1]) { // Strategy 1: Matched "Name:"
                speakerName = match[1].trim();
                const lowerSpeaker = speakerName.toLowerCase();
                isUser = userKeywordRegex.test(lowerSpeaker);
                isAi = aiKeywordRegex.test(lowerSpeaker);
                originalPrefix = match[0];

            } else { // Strategy 2: Fallback to keyword matching
                match = line.match(keywordSpeakerRegex);
                if (match && match[3]) {
                    speakerName = match[3];
                    const lowerSpeaker = speakerName.toLowerCase();
                    isUser = CONFIG.USER_KEYWORDS.includes(lowerSpeaker);
                    isAi = true; // If not user, assume AI by keyword list
                    originalPrefix = match[0];
                }
            }

            if (speakerName) {
                // Save previous segment if it has content
                if (currentSegment.content.trim()) {
                    segments.push(currentSegment);
                }

                // Determine speaker type. Default to AI if not explicitly a user keyword.
                const speakerType = isUser ? 'user' : 'ai';

                // Clean the line (remove the speaker part so it doesn't repeat inside the bubble)
                let cleanLine = line.replace(match[0], '').trim();

                currentSegment = {
                    type: speakerType,
                    speaker: speakerName.charAt(0).toUpperCase() + speakerName.slice(1), // Capitalize
                    content: cleanLine + '\n',
                    originalPrefix: originalPrefix
                };
            } else {
                // Continue current segment
                currentSegment.content += line + '\n';
            }
        });

        // Push final segment
        if (currentSegment.content.trim()) {
            segments.push(currentSegment);
        }
        
        // Ensure the very first segment has a prefix if it's just content
        if (segments.length > 0 && !segments[0].originalPrefix) {
            segments[0].originalPrefix = '';
        }

        // --- Infer first speaker if unknown ---
        if (segments.length > 1 && segments[0].type === 'unknown') {
            const firstKnownSegment = segments[1];
            if (firstKnownSegment.type === 'ai') {
                segments[0].type = 'user';
                segments[0].speaker = 'User';
            } else if (firstKnownSegment.type === 'user') {
                segments[0].type = 'ai';
                segments[0].speaker = 'Assistant';
            }
        }
        
        return segments;
    },

    parseByAlternatingTurns(text) {
        const blocks = text.trim().split(/\n\s*\n+/);
        if (blocks.length < 2) return [];
        const segments = [];
        let isUserTurn = true;
        blocks.forEach(block => {
            const content = block.trim();
            if (content) {
                segments.push({
                    type: isUserTurn ? 'user' : 'ai',
                    speaker: isUserTurn ? 'User' : 'Assistant',
                    content: content
                });
                isUserTurn = !isUserTurn;
            }
        });
        return segments;
    },

    parseByHeuristicSplit(text) {
        // This is a last-resort heuristic. It splits the text into paragraphs
        // separated by at least one blank line and assumes they are alternating turns.
        const blocks = text.trim().split(/\n\s*\n+/);
        if (blocks.length < 2) return [];

        return blocks.map((block, i) => ({
            type: i % 2 === 0 ? 'user' : 'ai',
            speaker: i % 2 === 0 ? 'User' : 'Assistant',
            content: block.trim()
        })).filter(seg => seg.content);
    }
    }; // End Parser Module

    // === RENDERER MODULE ===
    const Renderer = {
    renderChat(text, segments = null) {
        if (!text.trim()) {
            elements.output.innerHTML = '<p style="color:#9ca3af; font-style:italic; text-align:center;">Preview will appear here...</p>';
            return;
        }

        if (!segments) segments = Parser.parseSegments(text);
        
        if (segments.length <= 1) {
            const safeHTML = DOMPurify.sanitize(marked.parse(text));
            elements.output.innerHTML = `<div class="markdown-body standard-doc">${safeHTML}</div>`;
            return;
        }

        // Virtual DOM approach - only update changed bubbles
        const existingBubbles = elements.output.querySelectorAll('.chat-row');
        
        // Reuse existing container if possible
        let container = elements.output.querySelector('.chat-container');
        if (!container) {
            container = document.createElement('div');
            container.className = 'chat-container';
            elements.output.innerHTML = '';
            elements.output.appendChild(container);
        }
        
        segments.forEach((seg, index) => {
            if (!seg.content.trim()) return;
            
            let row = existingBubbles[index];
            // A simple diff check. More complex checks could compare data attributes.
            const needsUpdate = !row || 
                row.dataset.speaker !== seg.speaker ||
                row.dataset.content !== seg.content;
            
            if (needsUpdate) {
                const rawHtml = marked.parse(seg.content);
                const safeHtml = DOMPurify.sanitize(rawHtml);
                const alignClass = seg.type === 'user' ? 'user' : 'ai';
                
                const isDarkMode = document.body.classList.contains('dark-mode');
                const color = isDarkMode ? getColorForSpeaker(seg.speaker) : '';
                const style = color ? `style="border-color: ${color};"` : '';
                const labelHtml = seg.type !== 'unknown' 
                    ? `<div class="speaker-label" style="color: ${color};">${seg.speaker}</div>` 
                    : '';
                
                const newRow = document.createElement('div');
                newRow.className = `chat-row ${alignClass}`;
                newRow.dataset.speaker = seg.speaker; // Store state for diffing
                newRow.dataset.content = seg.content; // Store state for diffing
                newRow.innerHTML = `
                    <div class="chat-bubble" ${style}>
                        ${labelHtml}
                        <div class="markdown-body" contenteditable="true">${safeHtml}</div>
                    </div>
                `;
                
                if (row) {
                    container.replaceChild(newRow, row);
                } else {
                    container.appendChild(newRow);
                }
            }
        });
        
        // Remove extra bubbles if the new text has fewer segments
        while (container.children.length > segments.filter(s => s.content.trim()).length) {
            container.removeChild(container.lastChild);
        }
    }
    }; // End Renderer Module

    function convertBubbleHtmlToText(bubbleNode) {
        // CRITICAL SECURITY FIX: Sanitize the contenteditable HTML before processing to prevent XSS.
        // This returns a safe DOM fragment.
        // SECURE: Remove href attribute and restrict to safe tags only
        const safeFragment = DOMPurify.sanitize(bubbleNode.innerHTML, {
            ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'code', 'pre', 'ul', 'ol', 'li', 'blockquote'],
            ALLOWED_ATTR: ['class'], // Removed 'href' to prevent javascript: URLs
            RETURN_DOM_FRAGMENT: true,
            ALLOW_DATA_ATTR: false
        });

        // Process the sanitized fragment
        safeFragment.querySelectorAll('pre').forEach(pre => {
            const code = pre.querySelector('code');
            const lang = code ? (Array.from(code.classList).find(c => c.startsWith('language-')) || '').replace('language-', '') : '';
            const codeText = pre.textContent;
            // Replace the <pre> element with a markdown code fence text node
            pre.replaceWith(document.createTextNode(`\n\`\`\`${lang}\n${codeText}\n\`\`\`\n`));
        });
        
        // Convert <br> tags to newlines for manual line breaks
        safeFragment.querySelectorAll('br').forEach(br => br.replaceWith('\n'));
        
        // For other block elements, ensure they are separated by newlines
        safeFragment.querySelectorAll('p, ul, ol, blockquote').forEach(block => {
            // Insert a newline before the block if it's not the first element
            if (block.previousSibling) {
                block.before(document.createTextNode('\n'));
            }
        });
        
        // Use textContent to get the final plain text with preserved structures
        return safeFragment.textContent.trim();
    }

    function updateSourceFromPreview() {
        if (State.isUpdatingFromPreview) return;
        State.isUpdatingFromPreview = true;

        const segments = Parser.parseSegments(elements.input.value);
        const bubbles = elements.output.querySelectorAll('.markdown-body[contenteditable="true"]');

        if (segments.length !== bubbles.length) {
            // This can happen if the DOM is out of sync. A re-render is the safest option.
            showToast("Preview out of sync. Re-rendering from source.");
            State.isUpdatingFromPreview = false;
            handleInput(false); // Don't debounce, immediate update
            return;
        }

        let updatedText = '';
        segments.forEach((segment, index) => {
            const bubbleNode = bubbles[index];
            const newContent = convertBubbleHtmlToText(bubbleNode);
            updatedText += (segment.originalPrefix || '') + newContent + '\n\n';
        });
        elements.input.value = updatedText.trim();
        Storage.scheduleAutoSave();

        // Allow updates again after a short delay
        setTimeout(() => { State.isUpdatingFromPreview = false; }, 100);
    }

    // === STORAGE MODULE ===
    const Storage = {
    // Storage size limits
    MAX_INPUT_SIZE: 5 * 1024 * 1024,    // 5MB
    MAX_TITLE_SIZE: 500,                 // 500 chars
    MAX_FIELD_SIZE: 200,                 // 200 chars
    
    save() {
        try {
            // Check storage quota
            const storageSize = JSON.stringify(localStorage).length;
            if (storageSize > 10 * 1024 * 1024) { // 10MB total limit
                showToast("Storage limit reached. Please clear old data.");
                return;
            }
            
            const data = {
                input: elements.input.value.substring(0, this.MAX_INPUT_SIZE),
                title: elements.title.textContent.substring(0, this.MAX_TITLE_SIZE),
                date: elements.date.value.substring(0, this.MAX_FIELD_SIZE),
                source: elements.source.value.substring(0, this.MAX_FIELD_SIZE),
                timestamp: Date.now()
            };
            localStorage.setItem('chatExporter_save', JSON.stringify(data));
            showToast("Draft saved successfully");
        } catch (e) {
            console.error("Save failed:", e);
            showToast("Failed to save: " + e.message);
        }
    },
    load() {
        try {
            const autoSaveData = JSON.parse(localStorage.getItem('chatExporter_auto'));
            const manualSaveData = JSON.parse(localStorage.getItem('chatExporter_save'));

            const dataToLoad = (autoSaveData && autoSaveData.timestamp > (manualSaveData?.timestamp || 0))
                ? autoSaveData 
                : manualSaveData;

            if (!dataToLoad) {
                showToast("No saved draft found");
                return;
            }
            
            // SECURE: Comprehensive validation
            if (typeof dataToLoad !== 'object' || dataToLoad === null) {
                throw new Error('Invalid data format');
            }
            
            // Validate types
            if (typeof dataToLoad.input !== 'string' || 
                typeof dataToLoad.title !== 'string' ||
                typeof dataToLoad.date !== 'string' ||
                typeof dataToLoad.source !== 'string') {
                throw new Error('Invalid data structure');
            }
            
            // SECURE: Validate sizes BEFORE processing
            if (dataToLoad.input.length > this.MAX_INPUT_SIZE) {
                throw new Error('Input data too large');
            }
            if (dataToLoad.title.length > this.MAX_TITLE_SIZE) {
                throw new Error('Title too large');
            }
            if (dataToLoad.date.length > this.MAX_FIELD_SIZE ||
                dataToLoad.source.length > this.MAX_FIELD_SIZE) {
                throw new Error('Field data too large');
            }
            
            // SECURE: Sanitize all text inputs
            const cleanTitle = DOMPurify.sanitize(dataToLoad.title, {
                ALLOWED_TAGS: [],
                ALLOWED_ATTR: []
            });
            const cleanSource = DOMPurify.sanitize(dataToLoad.source, {
                ALLOWED_TAGS: [],
                ALLOWED_ATTR: []
            });
            const cleanDate = DOMPurify.sanitize(dataToLoad.date, {
                ALLOWED_TAGS: [],
                ALLOWED_ATTR: []
            });
            
            // Apply sanitized data
            elements.input.value = dataToLoad.input;
            elements.title.textContent = cleanTitle || 'Conversation Log';
            elements.date.value = cleanDate || new Date().toLocaleDateString();
            elements.source.value = cleanSource || 'AI Assistant';
            
            handleInput();
            showToast("Draft loaded");
        } catch (e) {
            console.error("Failed to load draft:", e);
            showToast("Failed to load draft: " + e.message);
            // Clear corrupted data
            localStorage.removeItem('chatExporter_auto');
            localStorage.removeItem('chatExporter_save');
        }
    },
    scheduleAutoSave() {
        if (State.autoSaveTimeout) {
            clearTimeout(State.autoSaveTimeout);
            State.autoSaveTimeout = null;
        }
        
        State.autoSaveTimeout = setTimeout(() => {
            try {
                // SECURE: Check storage usage
                const storageSize = JSON.stringify(localStorage).length;
                if (storageSize > 10 * 1024 * 1024) {
                    console.warn("Storage quota approaching limit");
                    elements.status.textContent = "Storage nearly full";
                    return;
                }
                
                const data = {
                    input: elements.input.value.substring(0, this.MAX_INPUT_SIZE),
                    title: elements.title.textContent.substring(0, this.MAX_TITLE_SIZE),
                    date: elements.date.value.substring(0, this.MAX_FIELD_SIZE),
                    source: elements.source.value.substring(0, this.MAX_FIELD_SIZE),
                    timestamp: Date.now()
                };
                localStorage.setItem('chatExporter_auto', JSON.stringify(data));
                elements.status.textContent = "Auto-saved";
                elements.status.classList.add('saved');
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    elements.status.textContent = "Save failed: Storage full";
                    showToast("Storage quota exceeded. Please export or clear data.");
                } else {
                    console.error("Auto-save failed:", e);
                    elements.status.textContent = "Save failed";
                }
            }
            setTimeout(() => {
                elements.status.textContent = "";
                elements.status.classList.remove('saved');
            }, 3000);
            State.autoSaveTimeout = null;
        }, CONFIG.AUTO_SAVE_DELAY);
    }
    }; // End Storage Module
    
    function clearText() {
        elements.input.value = '';
        resetFields();
        handleInput();
    }

    function showToast(msg) {
        const t = document.getElementById('toast');
        t.innerText = msg;
        t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 3000);
    }

    // === INITIALIZATION ===
    document.addEventListener('DOMContentLoaded', init);
</script>

</body>
</html>
